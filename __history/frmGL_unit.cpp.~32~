// ---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "frmGL_unit.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "RzPanel"
#pragma link "RzStatus"
#pragma link "RzButton"
#pragma link "RzSplit"
#pragma resource "*.dfm"
TfrmGL *frmGL;

// ---------------------------------------------------------------------------
__fastcall TfrmGL::TfrmGL(TComponent* Owner) : TForm(Owner) {
}
// ---------------------------------------------------------------------------

// TForm1::WMPaint(TWMPaint Msg) {
// TPaintStruct ps;
//
// BeginPaint(Handle, &ps);
// Rectangle(Canvas->Handle, 10, 10, 100, 100);
// EndPaint(Handle, &ps);
//
// }

/* =======================================================================
 Формат пикселя */
void __fastcall TfrmGL::SetDCPixelFormat(HDC hdc) {
	PIXELFORMATDESCRIPTOR pfd;
	int nPixelFormat = 0;

	ZeroMemory(&pfd, sizeof(pfd));
	pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
	nPixelFormat = ChoosePixelFormat(hdc, &pfd);
	SetPixelFormat(hdc, nPixelFormat, &pfd);
}

/* =======================================================================
 Создание формы */
void __fastcall TfrmGL::FormCreate(TObject* Sender) {
	hwnd1 = RzPanel1->Handle;
	dc1 = GetDC(hwnd1);
	SetDCPixelFormat(dc1);
	hrc1 = wglCreateContext(dc1);
	Randomize();
	R = Random();
	G = Random();
	B = Random();
	RzFieldStatus1->Caption = FloatToStr(R) + "  " + FloatToStr(G) + "  " + FloatToStr(B);

	xpos = RzPanel1->Width / 2.;
	ypos = RzPanel1->Height / 2.;

}

/* =======================================================================
 Рисование картинки *//* ======================================================================
 Перевод цвета из TColor в OpenGL */
void __fastcall TfrmGL::ColorToGL(TColor c, GLfloat &R, GLfloat &G, GLfloat &B) {
	R = (GLfloat)(c & 0xFF) / 255;
	G = (GLfloat)((c & 0xFF00) >> 8) / 255;
	B = (GLfloat)((c & 0xFF0000) >> 16) / 255;
	RzFieldStatus1->Caption = FloatToStr(R) + "  " + FloatToStr(G) + "  " + FloatToStr(B);
}

/* =======================================================================
 Конец работы приложения */
void __fastcall TfrmGL::FormDestroy(TObject *Sender) {
	wglDeleteContext(hrc1);
	wglDeleteContext(hrc2);
}

// ---------------------------------------------------------------------------
void __fastcall TfrmGL::RzToolButton1Click(TObject *Sender) {
	if (ColorDialog1->Execute()) {
		ColorToGL(ColorDialog1->Color, R, G, B);
	}
	RzPanel1->Refresh();
}

// ---------------------------------------------------------------------------
void __fastcall TfrmGL::RzPanel1Paint(TObject *Sender) {

	hwnd1 = RzPanel1->Handle;
	dc1 = GetDC(hwnd1);
	SetDCPixelFormat(dc1);
	hrc1 = wglCreateContext(dc1);
	Randomize();
	R = Random();
	G = Random();
	B = Random();

	PAINTSTRUCT ps;

	// BeginPaint(hwnd2, &ps);
	wglMakeCurrent(dc1, hrc1);
	glViewport(0, 0, RzPanel1->Width, RzPanel1->Height); // область вывода
	glClearColor(R, G, B, 1.0); // цвет фона
	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета
	glPointSize(5); // размер точек
	glColor3f(1.0, 0.0, 0.5); // текущий цвет примитивов
	glEnable(GL_POINT_SMOOTH);
	glBegin(GL_POINTS); // открываем командную скобку
	glVertex2f(-1, -1);
	glVertex2f(-1, 1);
	glVertex2f(0, 0);
	glVertex2f(1, -1);
	glVertex2f(1, 1);

	GLfloat a, b, x;
	GLint i, num;
	a = -M_PI; // начало интервала
	b = M_PI; // конец интервала
	num = 2000; // количество точек на интервале

	for (i = 0; i <= num; i++) {
		x = a + i * (b - a) / num;
		glVertex2f(2 * (x - a) / (b - a) - 1.0, sin(x) * 0.75);

	}
	glEnd();

	SwapBuffers(dc1);
	wglMakeCurrent(0, 0);
	// EndPaint(hwnd2, &ps);
}
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------6

void __fastcall TfrmGL::OpenGL1Click(TObject *Sender)

{
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	Randomize();
	R = Random();
	G = Random();
	B = Random();

	PAINTSTRUCT ps;

	// BeginPaint(hwnd2, &ps);
	wglMakeCurrent(dc2, hrc2);
	glViewport(0, 0, RzPanel2->Width, RzPanel2->Height); // область вывода
	glClearColor(R, G, B, 1.0); // цвет фона
	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета
	glPointSize(5); // размер точек
	glColor3f(1.0, 0.0, 0.5); // текущий цвет примитивов
	glEnable(GL_POINT_SMOOTH);
	glBegin(GL_POINTS); // открываем командную скобку
	glVertex2f(-1, -1);
	glVertex2f(-1, 1);
	glVertex2f(0, 0);
	glVertex2f(1, -1);
	glVertex2f(1, 1);

	GLfloat a, b, x;
	GLint i, num;
	a = -M_PI; // начало интервала
	b = M_PI; // конец интервала
	num = 2000; // количество точек на интервале

	for (i = 0; i <= num; i++) {
		x = a + i * (b - a) / num;
		glVertex2f(2 * (x - a) / (b - a) - 1.0, cos(x));

	}
	glEnd();

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
	// EndPaint(hwnd2, &ps);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::OpenGLGDI2Click(TObject *Sender) {
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	Randomize();
	R = Random();
	G = Random();
	B = Random();

	PAINTSTRUCT ps;

	// BeginPaint(hwnd2, &ps);
	wglMakeCurrent(dc2, hrc2);
	glViewport(0, 0, RzPanel2->Width, RzPanel2->Height); // область вывода
	glClearColor(R, G, B, 1.0); // цвет фона
	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
	// EndPaint(hwnd2, &ps);

	RzPanel2->Canvas->Brush->Color = clGreen;
	RzPanel2->Canvas->Ellipse(400, 400, 450, 450);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::OpenGLlines1Click(TObject *Sender) {
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);
	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета
	// glLineWidth (1);
	glEnable(GL_LINE_SMOOTH);
	glBegin(GL_LINES);
	glVertex2f(-1, 1);
	glVertex2f(1, -1);
	glVertex2f(-1, -1);
	glVertex2f(1, 1);
	glEnd();
	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::OpenGLOxOy1Click(TObject *Sender)

{
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);
	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета

	glPointSize(5); // размер точек
	glColor3f(1.0, 0.0, 0.5); // текущий цвет примитивов
	glEnable(GL_POINT_SMOOTH);
	glBegin(GL_POINTS); // открываем командную скобку
	glVertex2f(0, 0);
	glEnd();

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);

}

// ---------------------------------------------------------------------------

void __fastcall TfrmGL::BezierCurvewithFourControlPoints1Click(TObject *Sender) {
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);

	GLfloat ctrlpoints[4][3] = { {-4.0, -4.0, 0.0}, {-2.0, 4.0, 0.0}, {2.0, -4.0, 0.0}, {4.0, 4.0, 0.0}};

	GLsizei w = RzPanel2->Width;
	GLsizei h = RzPanel2->Height;
	glViewport(0, 0, (GLsizei) w, (GLsizei) h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (w <= h)
		glOrtho(-5.0, 5.0, -5.0*(GLfloat)h / (GLfloat)w, 5.0*(GLfloat)h / (GLfloat)w, -5.0, 5.0);
	else
		glOrtho(-5.0*(GLfloat)w / (GLfloat)h, 5.0*(GLfloat)w / (GLfloat)h, -5.0, 5.0, -5.0, 5.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glClearColor(0.0, 0.0, 0.0, 0.0);
	glShadeModel(GL_FLAT);
	glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 4, &ctrlpoints[0][0]);
	glEnable(GL_MAP1_VERTEX_3);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);
	glLineWidth(1);
	glEnable(GL_LINE_SMOOTH);
	glBegin(GL_LINE_STRIP);
	for (GLint i = 0; i <= 30; i++)
		glEvalCoord1f((GLfloat) i / 30.0);
	glEnd();
	/* The following code displays the control points as dots. */
	glPointSize(5.0);
	glColor3f(1.0, 1.0, 0.0);
	glBegin(GL_POINTS);
	for (GLint i = 0; i < 4; i++)
		glVertex3fv(&ctrlpoints[i][0]);
	glEnd();
	glFlush();

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::OpenGLlinesstrip1Click(TObject *Sender) {
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);

	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета

	glColor3f(1.0, 1.0, 1.0);
	glLineWidth(2);
	glEnable(GL_LINE_SMOOTH);
	glBegin(GL_LINE_STRIP);
	glVertex2f(-0.8, -0.8);
	glVertex2f(-0.8, 0.8);
	glVertex2f(0.8, 0.8);
	glVertex2f(0.8, -0.8);
	glEnd();

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);

}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::OpenGLlinesloop1Click(TObject *Sender)

{
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);

	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета

	glColor3f(1.0, 1.0, 1.0);
	glLineWidth(2);
	glEnable(GL_LINE_SMOOTH);
	glBegin(GL_LINE_LOOP);
	glVertex2f(-0.8, -0.8);
	glVertex2f(-0.8, 0.8);
	glVertex2f(0.8, 0.8);
	glVertex2f(0.8, -0.8);
	glEnd();

	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::RzPanel2MouseMove(TObject *Sender, TShiftState Shift, int X, int Y)

{
	xpos = 2. * X / RzPanel1->Width - 1;
	ypos = 2. * (RzPanel1->Height - Y) / RzPanel1->Height - 1;
	if (mode1)
		Randomlines1Click(this);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::Randomlines1Click(TObject *Sender)

{
	mode1 = true;
	if (mode1) {

		hwnd2 = RzPanel2->Handle;
		dc2 = GetDC(hwnd2);
		SetDCPixelFormat(dc2);
		hrc2 = wglCreateContext(dc2);
		wglMakeCurrent(dc2, hrc2);
		glViewport(0, 0, RzPanel2->Width, RzPanel2->Height); // область вывода
		glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета
		glEnable(GL_LINE_STIPPLE);
		for (GLint i = 1; i < 100; i++) {
			glColor3f(Random(), Random(), Random());
			glLineStipple(Random(5), Random(0xFFFF));
			glBegin(GL_LINES);
			glVertex2f(xpos, ypos);
			glVertex2f(xpos + 0.5 * Random() * Sin(Random(360)), ypos + 0.5 * Random() * Cos(Random(360)));
			glEnd();
		}
		SwapBuffers(dc2);
		wglMakeCurrent(0, 0);
	}

}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::RzPanel2Paint(TObject *Sender)

{
	OpenGL1Click(this);
}
// ---------------------------------------------------------------------------

void __fastcall TfrmGL::riangles1Click(TObject *Sender)

{
	mode1 = false;
	hwnd2 = RzPanel2->Handle;
	dc2 = GetDC(hwnd2);
	SetDCPixelFormat(dc2);
	hrc2 = wglCreateContext(dc2);
	wglMakeCurrent(dc2, hrc2);

	glClear(GL_COLOR_BUFFER_BIT); // очистка буфера цвета

	glColor3f(1.0, 0.0, 0.5); // текущий цвет примитивов
	glBegin(GL_TRIANGLES);
	glVertex2f(-1, -1);
	glVertex2f(-1, 1);
	glVertex2f(0.1, 0);
	glEnd();

	glBegin(GL_TRIANGLES);
	for (GLint i = 0; i < 5; i++) {
		glVertex2f(0, 0);
		glVertex2f(0.5 * cos(2 * Pi * i / 6), 0.5 * sin(2 * Pi * i / 6));
		glVertex2f(0.5 * cos(2 * Pi * (i + 1) / 6), 0.5 * sin(2 * Pi * (i + 1) / 6));
	}
	glEnd();
	SwapBuffers(dc2);
	wglMakeCurrent(0, 0);
}
// ---------------------------------------------------------------------------
